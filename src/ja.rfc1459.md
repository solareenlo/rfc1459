## 7. Client and server authentication
クライアントもサーバも同じレベルの認証が行われます．両者とも，サーバへのすべての接続について，IP 番号とホスト名のルックアップ（およびこの逆チェック）が実行されます．その後，両方の接続に対してパスワードチェックが行われます (その接続にパスワードが設定されている場合)．これらのチェックはすべての接続で可能ですが，パスワードチェックはサーバでのみ一般的に使用されます．

さらに，最近増えているのが，接続に使用したユーザ名のチェックです．接続の相手側のユーザ名を見つけるには，通常，RFC1413 に記載されている IDENT などの認証サーバに接続する必要があります．

パスワードがなければ，ネットワーク接続の相手方を確実に特定することは容易ではないため，サーバ間接続では，ID サーバの使用などの対策に加え，パスワードの使用を強く推奨します．

## 8. Current implementations
このプロトコルの現在の実装は，IRCサーバのバージョン2.8のみです．それ以前のバージョンでは，このドキュメントで説明されているコマンドの一部または全部を，数値応答の多くを NOTICE メッセージに置き換えて実装しているかもしれません．残念ながら，後方互換性の要求のために，この文書のいくつかの部分の実装は，レイアウトされたものと異なっています．顕著な違いとしては

* メッセージ内の任意の LF または CR がそのメッセージの終わりを示すという認識（CR-LFを要求する代わりに）．

この章の残りの部分は，主にサーバを実装しようとする人にとって重要な問題を扱っていますが，いくつかの部分はクライアントにも直接適用されます．

### 8.1 Network protocol: TCP - why it is best used here.
IRC は，TCP がこの規模の会議に適した信頼性の高いネットワークプロトコルを提供しているため，TCP の上に実装されています．マルチキャスト IP の利用も考えられるが，現時点では広く普及し ておらず，サポートされていません．

#### 8.1.1 Support of Unix sockets
Unilx ドメインソケットはリスン/コネクト操作が可能であることから，現在の実装では，Unix ドメインソケット上でクライアントとサーバの両方の接続をリスンして受け入れるように設定することができます．これは，ホスト名が ’/’ で始まるソケットとして認識されます．

Unix ドメインソケットの接続に関する情報を提供する場合，実際のソケット名を要求されない限り，サーバはパス名の代わりに実際のホスト名を指定する必要があります．

### 8.2 Command Parsing
クライアントとサーバに便利な’非バッファード’ネットワークIOを提供するために，各接続には専用の’入力バッファ’が与えられ，最新の読み取りと解析の結果が保持されます．バッファのサイズは512バイトで，1つの完全なメッセージを保持することができます．プライベートバッファは，有効なメッセージの読み取り操作のたびに解析されます．一つのクライアントからの複数のメッセージをバッファで扱う場合，あるメッセージによってクライアントが’削除’されることがないように注意する必要があります．

### 8.3 Message delivery
ネットワークリンクが飽和したり，データ送信先のホストがデータ送信できなくなることはよくあることです．Unix は通常，TCP ウィンドウと内部バッファによってこれを処理しますが， サーバはしばしば大量の送信データを持ち（特に新しいサーバとサーバのリンクが形成されたとき）， カーネルで提供される小さなバッファでは送信キューに十分ではありません．この問題を軽減するために，送信するデータの FIFO キューとして"送信キュー"が使用されます．典型的な"送信キュー"は，新しいサーバが接続するとき，遅いネットワーク接続を持つ大きな IRC ネットワーク上で200Kバイトに成長するかもしれません．

接続をポーリングする際，サーバはまず受信データをすべて読み込んで解析し，送信すべきデータがあればキューに入れます．利用可能なすべての入力が処理されると，キューに入れられたデータが送信されます．これにより，write() システムコールの回数が減り，TCP がより大きなパケットを作成できるようになります．

### 8.4 Connection ’Liveness’
接続が切れたり応答しなくなったりしたことを検知するために，サーバは一定時間内に応答がない接続に対してそれぞれ ping を打つ必要があります．

接続が時間内に応答しない場合，その接続は適切な手順で閉じられます．サーバプロセスがブロックされるよりも遅い接続を閉じる方が良いので，sendq が許容範囲を超えて大きくなった場合にも，接続は切断されます．

### 8.5 Establishing a server to client connection
IRC サーバに接続すると，LUSER コマンドにより，MOTD と現在のユーザ/サーバ数がクライアントに送信されます．また，サーバはクライアントに対して，サーバ名とバージョン，その他適切と思われる紹介メッセージを明確に伝えることが要求されます．

これを処理した後，サーバは新しいユーザのニックネームやその他の情報を自分自身（USER コマンド）で提供したり，サーバが DNS/認証サーバから発見したものを送信する必要があります．サーバは，この情報を NICK の後に USER を付けて送信しなければなりません．

### 8.6 Establishing a server-server connection.
サーバ間の接続は，競合状態をはじめ，さまざまな問題が発生する可能性があるため，危険と隣り合わせのプロセスです．

サーバは，有効であると認識された PASS/SERVER のペアに続く接続を受け取った後，その接続のための自身の PASS/SERVER 情報と，以下に述べるように知っている他のすべての状態情報を返信する必要があります．

開始サーバは PASS/SERVER のペアを受け取ると，応答したサーバが適切に認証されていることを確認した上で，そのサーバへの接続を受け入れます．

#### 8.6.1 Server exchange of state information when connecting
サーバ間で交換される状態情報の順序が重要です．必要な順序は以下の通りです．

* 他のすべての既知のサーバ
* すべての既知のユーザ情報
* すべての既知のチャネル情報

サーバに関する情報は SERVER メッセージ，ユーザ情報は NICK/USER/MODE/JOIN メッセージ，チャネルは MODE メッセージで追加送信されます．

NOT: TOPIC コマンドは古いトピック情報を上書きするため，ここではチャネルトピックは交換されず，せいぜい接続の両側がトピックを交換する程度です．

サーバの状態情報を先に渡すことで，第二サーバが特定のニックネームを導入することによるニックネームの衝突よりも先に，既に存在するサーバとの衝突が発生します．IRC ネットワークは非循環グラフとしてしか存在できないため，ネットワークがすでに別の場所で再接続されている可能性があり，衝突が発生した場所はネットを分割する必要がある場所であることを示しています．

### 8.7 Terminating server-client connections
クライアント接続が終了すると，そのクライアントが接続したサーバがクライアントに代わって QUIT メッセージを生成します．他のメッセージは生成されず，使用されません．

### 8.8 Terminating server-server connections
サーバとサーバの接続が，リモートで生成された SQUIT または’自然な’原因によって閉じられた場合，接続されている残りのIRCネットワークは，閉鎖を検出したサーバによってその情報が更新されなければなりません．サーバは，SQUIT のリスト(その接続の背後にある各サーバについて1つ)とQUITのリスト(再び，その接続の背後にある各クライアントについて1つ)を送信します．

### 8.9 Tracking nickname changes
すべての IRC サーバは最近のニックネームの変更履歴を保持することが要求されます．これは，ニックネームを操作するコマンドでニックネーム変更の競合状態が発生したときに，サーバが状況を把握する機会を持つために必要です．ニックネームの変更を追跡しなければならないコマンドは以下の通りです．

* KILL（キルされるニックネーム）
* MODE（+/- o,v）
* KICK（キックされるニックネーム）

他のコマンドは，ニックネームの変更をチェックさせません．

上記の場合，サーバはまずニックネームの存在を確認し，次にそのニックネームが現在誰に属しているかを確認するために履歴をチェックする必要があります (もし誰かいればですが!)．これは競合状態の可能性を減らしますが，サーバが間違ったクライアントに影響を及ぼしてしまうということはまだ起こり得ます．上記のコマンドで変更履歴を調べるときは，時間範囲を指定し，古すぎるエントリは無視することをお勧めします．

合理的な履歴のために，サーバは，すべてのクライアントが変更することを決めた場合，サーバが知っているすべてのクライアントのために前のニックネームを保持することができるはずです．このサイズは他の要因(例えばメモリなど)によって制限されます．

### 8.10 Flood control of clients
IRC サーバが相互に接続された大規模なネットワークでは，ネットワークに接続している任意の1つのクライアントが連続的にメッセージを供給することは非常に簡単で，その結果，ネットワークが氾濫するだけでなく，他のクライアントに提供するサービスのレベルを低下させることになるのです．大量リクエスト対策は，すべての’犠牲者’に独自の対策を要求するのではなく，サーバに書き込まれ，サービスを除くすべてのクライアントに適用されます．現在のアルゴリズムは以下の通りである．

* クライアントの‘メッセージタイマー‘が現在の時刻より小さいかどうかを確認します（小さい場合は等しくなるように設定します）．
* クライアントから存在するあらゆるデータを読み取ります．
* タイマーが現在時刻より10秒以上進んでいる間に，現在のメッセージを解析し，メッセージごとにクライアントに2秒のペナルティーを課します．

これは要するに，クライアントが2秒に1回メッセージを送信しても悪影響がないことを意味します．

### 8.11 Non-blocking lookups
リアルタイム環境では，すべてのクライアントに公平にサービスを提供するために，サーバプロセスができるだけ待機しないことが重要です．このためには，ネットワーク上のすべての読み取り/書き込み操作において，ノンブロッキング IO が必要であることは明らかです．通常のサーバ接続では，これは難しいことではありませんでしたが，サーバがブロックする可能性がある他のサポート操作（ディスク読み取りなど）があります．可能であれば，そのような動作は短いタイムアウトで実行されるべきです．

#### 8.11.1 Hostname (DNS) lookups
Berkeley などの標準的なリゾルバライブラリを使用すると，返信がタイムアウトになるケースがあり，大きな遅延が発生しました．これを避けるために，DNS ルーチンの別セットが書かれました．これは，ノンブロッキング IO オペレーション用にセットアップされ，メインサーバの IO ループの中からポーリングされます．

#### 8.11.2 Username (Ident) lookups
他のプログラムに組み込んで使用するための ident ライブラリは数多く存在しますが，これらは同期的に動作するため，遅延が頻繁に発生するという問題がありました．この場合も，サーバの他の部分と協調し，ノンブロッキング IO で動作するルーチン群を書くことが解決策となりました．

### 8.12 Configuration File
サーバの設定や運用を柔軟に行うために，以下のようなサーバへの指示を含む設定ファイルを使用することが推奨されます．

* クライアントからの接続を受け付けるホストを指定します．
* サーバとして接続を許可するホストを指定します．
* サーバとして接続を許可するホストを指定します．
* どのホストに接続するか（アクティブおよびパッシブの両方）．
* サーバがどこにあるかという情報（大学，都市／州，会社がその例です）．
* サーバの責任者と連絡可能な電子メールアドレス．
* 制限されたオペレータコマンドへのアクセスを希望するクライアントのホスト名とパスワード．

ホスト名の指定は，ドメイン名とドット表記（127.0.0.1）の両方が可能である必要があります．送信および受信のすべての接続で使用/受信するパスワードを指定できるようにしなければなりません（ただし，送信接続は他のサーバへの接続のみ）．

上記のリストは，他のサーバとの接続を希望するサーバに最低限必要なものです．その他，参考になる項目は以下の通りです．

* 他のサーバが導入できるサーバを指定する．
* サーバの分岐をどこまで深くするか．
* クライアントが接続可能な時間帯

#### 8.12.1 Allowing clients to connect
サーバは，起動時に読み込まれるある種の’アクセス制御リスト’（設定ファイルまたはその他の場所）を使用して，クライアントが接続するために使用するホストを決定する必要があります．

ホストアクセス制御に必要な柔軟性を提供するために，’deny’ と ’allow’ の両方を実装する必要があります．

#### 8.12.2 Operators
破壊的な人物にオペレータの特権を与えることは，その人物に与えられた権限によって，IRC ネット全般の幸福に悲惨な結果をもたらす可能性があります．したがって，そのような権限の取得は非常に簡単であってはなりません．現在の設定では，2つの ’パスワード’ が必要ですが，そのうちの1つは通常簡単に推測されます．オペレーティングシステムのパスワードを設定ファイルに保存することは，ハードコーディングするよりも望ましく，簡単に盗まれないように暗号化されたフォーマットで保存されるべきです (例えば，Unix の crypt(3) を使用します)．

#### 8.12.3 Allowing servers to connect
サーバの相互接続は些細なことではありません．接続不良は IRC の有用性に大きな影響を与える可能性があります．したがって，各サーバは接続できるサーバのリストと，どのサーバがそれに接続できるかのリストを持つべきです．どんな場合でも，サーバは任意のホストがサーバとして接続することを許可してはいけません．どのサーバが接続できて，どのサーバが接続できないかに加えて，設定ファイルにはそのリンクのパスワードや他の特性も保存されるべきです．

#### 8.12.4 Administrivia
ADMIN コマンド（[4.3.7 Admin command](#437-admin-command) 項参照）に対して正確で有効な返答をするために，サーバは設定から関連する詳細を見つけ出す必要があります．

### 8.13 Channel membership
現在のサーバでは，登録したローカルユーザが最大10個の異なるチャネルに参加することができます．非ローカルユーザには制限がないため，サーバはチャネルメンバーシップに関して他のすべてのユーザと（合理的に）一貫性を保つことができます．

## 9. Current problems
このプロトコルにはいくつかの問題があるとされており，近い将来，書き換えの際に解決されることが期待されています．現在，これらの問題に対する実用的な解決策を見つけるための作業が進行中です．

### 9.1 Scalability
このプロトコルは，大規模な舞台で使用する場合，十分にスケールしないことが広く認識されています．主な問題は，すべてのサーバが他のすべてのサーバとユーザについて知っており，それらに関する情報が変更されるとすぐに更新されるという要件から来るものです．また，任意の2点間の経路長が最小に保たれ，スパニングツリーができるだけ強く分岐するように，サーバの数を少なくすることが望まれます．

### 9.2 Labels
現在のIRCプロトコルには，ニックネーム，チャネル名，サーバ名の3種類のラベルがあります．3つのタイプはそれぞれ独自のドメインを持っており，そのドメイン内では重複が許されません． 現状では，ユーザが3種類のラベルのどれかを選ぶことが可能であり，その結果，衝突が発生しています．チャネル名とニックネームが衝突しないような一意な名前にする計画や，サイクリック・ツリーを可能にするソリューションが望ましいと広く認識されています．

#### 9.2.1 Nicknames
IRC におけるニックネームの考え方は，ユーザがチャネル外で会話する際に非常に便利ですが，ニックネームのスペースは有限であり，複数の人が同じニックネームを使いたいと思うことは珍しいことではありません．もしこのプロトコルを使って二人がニックネームを選んだ場合，どちらかが成功しないか，KILL ([4.6.1 Kill message](#461-kill-message)) を使うことで両方が削除されるでしょう．

#### 9.2.2 Channels
現在のチャネルレイアウトでは，すべてのサーバがすべてのチャネル，その住人，プロパティについて知っている必要があります．うまく拡張できないことに加えて，プライバシーの問題も懸念されます．チャネルの衝突は，ニックネームの衝突を解決するために使用されるような排他的なものではなく，新しいチャネルを作成した両方の人々がそのメンバーであるとみなされる包括的なイベントとして扱われます．

#### 9.2.3 Servers
サーバの数は通常，ユーザやチャネルの数に比べて少ないのですが，現在，2つのサーバはそれぞれ個別に，またはマスクの後ろに隠されて，グローバルに知られていることが要求されています．

###  9.3 Algorithms
サーバコード内のいくつかの場所では，クライアントのセットのチャネルリストをチェックするようなN^2アルゴリズムを回避することができませんでした．

現在のサーバのバージョンでは，データベースの整合性チェックがなく，各サーバは隣接するサーバが正しいことを前提にしています．そのため，接続先のサーバがバグっていたり，既存のネットに矛盾を持ち込もうとしたりすると，大きな問題が発生する可能性があります．

現在，内部およびグローバルラベルが一意でないため，多数の競合状態が存在します．これらの競合状態は，一般に，メッセージが IRC ネットワークを横断して影響を及ぼすのに時間がかかるという問題から発生します．一意なラベルに変更することによっても，チャネル関連のコマンドが中断される問題があります．
